Terminals unused in grammar

   ELSE
   IN
   LT


Grammar

    0 $accept: P $end

    1 P: functions

    2 functions: fx functions
    3          | %empty

    4 fx: FUNCTION id SEMICOLON BEGIN_PARAMS decs END_PARAMS BEGIN_LOCALS decs END_LOCALS BEGIN_BODY statements END_BODY

    5 decs: dec SEMICOLON decs
    6     | %empty

    7 dec: ids COLON INTEGER
    8    | ids COLON ARRAY L_SQUARE_BRACKET number R_SQUARE_BRACKET OF INTEGER

    9 ids: id
   10    | id COMMA ids

   11 id: IDENT

   12 statements: statement SEMICOLON statements
   13           | statement SEMICOLON

   14 statement: st_return
   15          | st_continue
   16          | st_break
   17          | st_write
   18          | st_read
   19          | st_while
   20          | st_if
   21          | st_var
   22          | st_do
   23          | st_for

   24 st_break: BREAK

   25 st_return: RETURN expression

   26 st_continue: CONTINUE

   27 st_write: WRITE x

   28 st_read: READ x

   29 st_while: WHILE bool_exp BEGIN_LOOP statements END_LOOP

   30 st_if: IF bool_exp THEN statements ENDIF

   31 st_do: DO BEGIN_LOOP statements END_LOOP

   32 st_for: FOR x ASSIGN number SEMICOLON bool_exp SEMICOLON x ASSIGN expression BEGIN_LOOP statements END_LOOP

   33 bool_exp: relation_exps
   34         | bool_exp OR relation_exps

   35 relation_exps: relation_exp
   36              | relation_exps AND relation_exp

   37 relation_exp: NOT exp_comp
   38             | exp_comp
   39             | TRUE
   40             | FALSE
   41             | L_PAREN bool_exp R_PAREN

   42 exp_comp: expression comp expression

   43 comp: EQ
   44     | NEQ
   45     | GT
   46     | LTE
   47     | GTE

   48 st_var: x ASSIGN expression

   49 x: id
   50  | id L_SQUARE_BRACKET expression R_SQUARE_BRACKET
   51  | id L_SQUARE_BRACKET expression R_SQUARE_BRACKET L_SQUARE_BRACKET expression R_SQUARE_BRACKET

   52 expression: multiplicative_exp add_sub_exp

   53 multiplicative_exp: term
   54                   | term MULT multiplicative_exp
   55                   | term DIV multiplicative_exp
   56                   | term MOD multiplicative_exp

   57 add_sub_exp: ADD expression
   58            | SUB expression
   59            | %empty

   60 term: x
   61     | number
   62     | L_PAREN expression R_PAREN
   63     | id L_PAREN expression exp_loop R_PAREN

   64 number: NUMBER

   65 exp_loop: COMMA expression exp_loop
   66         | %empty


Terminals, with rules where they appear

$end (0) 0
error (256)
NUMBER (258) 64
IDENT (259) 11
FUNCTION (260) 4
BEGIN_PARAMS (261) 4
END_PARAMS (262) 4
BEGIN_LOCALS (263) 4
END_LOCALS (264) 4
BEGIN_BODY (265) 4
END_BODY (266) 4
INTEGER (267) 7 8
ARRAY (268) 8
OF (269) 8
IF (270) 30
THEN (271) 30
ENDIF (272) 30
ELSE (273)
WHILE (274) 29
DO (275) 31
IN (276)
BEGIN_LOOP (277) 29 31 32
END_LOOP (278) 29 31 32
BREAK (279) 24
CONTINUE (280) 26
READ (281) 28
WRITE (282) 27
TRUE (283) 39
FALSE (284) 40
RETURN (285) 25
FOR (286) 32
AND (287) 36
OR (288) 34
NOT (289) 37
SUB (290) 58
ADD (291) 57
MULT (292) 54
DIV (293) 55
MOD (294) 56
EQ (295) 43
NEQ (296) 44
LT (297)
GT (298) 45
LTE (299) 46
GTE (300) 47
SEMICOLON (301) 4 5 12 13 32
COLON (302) 7 8
COMMA (303) 10 65
L_PAREN (304) 41 62 63
R_PAREN (305) 41 62 63
L_SQUARE_BRACKET (306) 8 50 51
R_SQUARE_BRACKET (307) 8 50 51
ASSIGN (308) 32 48


Nonterminals, with rules where they appear

$accept (54)
    on left: 0
P (55)
    on left: 1, on right: 0
functions (56)
    on left: 2 3, on right: 1 2
fx (57)
    on left: 4, on right: 2
decs (58)
    on left: 5 6, on right: 4 5
dec (59)
    on left: 7 8, on right: 5
ids (60)
    on left: 9 10, on right: 7 8 10
id (61)
    on left: 11, on right: 4 9 10 49 50 51 63
statements (62)
    on left: 12 13, on right: 4 12 29 30 31 32
statement (63)
    on left: 14 15 16 17 18 19 20 21 22 23, on right: 12 13
st_break (64)
    on left: 24, on right: 16
st_return (65)
    on left: 25, on right: 14
st_continue (66)
    on left: 26, on right: 15
st_write (67)
    on left: 27, on right: 17
st_read (68)
    on left: 28, on right: 18
st_while (69)
    on left: 29, on right: 19
st_if (70)
    on left: 30, on right: 20
st_do (71)
    on left: 31, on right: 22
st_for (72)
    on left: 32, on right: 23
bool_exp (73)
    on left: 33 34, on right: 29 30 32 34 41
relation_exps (74)
    on left: 35 36, on right: 33 34 36
relation_exp (75)
    on left: 37 38 39 40 41, on right: 35 36
exp_comp (76)
    on left: 42, on right: 37 38
comp (77)
    on left: 43 44 45 46 47, on right: 42
st_var (78)
    on left: 48, on right: 21
x (79)
    on left: 49 50 51, on right: 27 28 32 48 60
expression (80)
    on left: 52, on right: 25 32 42 48 50 51 57 58 62 63 65
multiplicative_exp (81)
    on left: 53 54 55 56, on right: 52 54 55 56
add_sub_exp (82)
    on left: 57 58 59, on right: 52
term (83)
    on left: 60 61 62 63, on right: 53 54 55 56
number (84)
    on left: 64, on right: 8 32 61
exp_loop (85)
    on left: 65 66, on right: 63 65


State 0

    0 $accept: . P $end

    FUNCTION  shift, and go to state 1

    $default  reduce using rule 3 (functions)

    P          go to state 2
    functions  go to state 3
    fx         go to state 4


State 1

    4 fx: FUNCTION . id SEMICOLON BEGIN_PARAMS decs END_PARAMS BEGIN_LOCALS decs END_LOCALS BEGIN_BODY statements END_BODY

    IDENT  shift, and go to state 5

    id  go to state 6


State 2

    0 $accept: P . $end

    $end  shift, and go to state 7


State 3

    1 P: functions .

    $default  reduce using rule 1 (P)


State 4

    2 functions: fx . functions

    FUNCTION  shift, and go to state 1

    $default  reduce using rule 3 (functions)

    functions  go to state 8
    fx         go to state 4


State 5

   11 id: IDENT .

    $default  reduce using rule 11 (id)


State 6

    4 fx: FUNCTION id . SEMICOLON BEGIN_PARAMS decs END_PARAMS BEGIN_LOCALS decs END_LOCALS BEGIN_BODY statements END_BODY

    SEMICOLON  shift, and go to state 9


State 7

    0 $accept: P $end .

    $default  accept


State 8

    2 functions: fx functions .

    $default  reduce using rule 2 (functions)


State 9

    4 fx: FUNCTION id SEMICOLON . BEGIN_PARAMS decs END_PARAMS BEGIN_LOCALS decs END_LOCALS BEGIN_BODY statements END_BODY

    BEGIN_PARAMS  shift, and go to state 10


State 10

    4 fx: FUNCTION id SEMICOLON BEGIN_PARAMS . decs END_PARAMS BEGIN_LOCALS decs END_LOCALS BEGIN_BODY statements END_BODY

    IDENT  shift, and go to state 5

    $default  reduce using rule 6 (decs)

    decs  go to state 11
    dec   go to state 12
    ids   go to state 13
    id    go to state 14


State 11

    4 fx: FUNCTION id SEMICOLON BEGIN_PARAMS decs . END_PARAMS BEGIN_LOCALS decs END_LOCALS BEGIN_BODY statements END_BODY

    END_PARAMS  shift, and go to state 15


State 12

    5 decs: dec . SEMICOLON decs

    SEMICOLON  shift, and go to state 16


State 13

    7 dec: ids . COLON INTEGER
    8    | ids . COLON ARRAY L_SQUARE_BRACKET number R_SQUARE_BRACKET OF INTEGER

    COLON  shift, and go to state 17


State 14

    9 ids: id .
   10    | id . COMMA ids

    COMMA  shift, and go to state 18

    $default  reduce using rule 9 (ids)


State 15

    4 fx: FUNCTION id SEMICOLON BEGIN_PARAMS decs END_PARAMS . BEGIN_LOCALS decs END_LOCALS BEGIN_BODY statements END_BODY

    BEGIN_LOCALS  shift, and go to state 19


State 16

    5 decs: dec SEMICOLON . decs

    IDENT  shift, and go to state 5

    $default  reduce using rule 6 (decs)

    decs  go to state 20
    dec   go to state 12
    ids   go to state 13
    id    go to state 14


State 17

    7 dec: ids COLON . INTEGER
    8    | ids COLON . ARRAY L_SQUARE_BRACKET number R_SQUARE_BRACKET OF INTEGER

    INTEGER  shift, and go to state 21
    ARRAY    shift, and go to state 22


State 18

   10 ids: id COMMA . ids

    IDENT  shift, and go to state 5

    ids  go to state 23
    id   go to state 14


State 19

    4 fx: FUNCTION id SEMICOLON BEGIN_PARAMS decs END_PARAMS BEGIN_LOCALS . decs END_LOCALS BEGIN_BODY statements END_BODY

    IDENT  shift, and go to state 5

    $default  reduce using rule 6 (decs)

    decs  go to state 24
    dec   go to state 12
    ids   go to state 13
    id    go to state 14


State 20

    5 decs: dec SEMICOLON decs .

    $default  reduce using rule 5 (decs)


State 21

    7 dec: ids COLON INTEGER .

    $default  reduce using rule 7 (dec)


State 22

    8 dec: ids COLON ARRAY . L_SQUARE_BRACKET number R_SQUARE_BRACKET OF INTEGER

    L_SQUARE_BRACKET  shift, and go to state 25


State 23

   10 ids: id COMMA ids .

    $default  reduce using rule 10 (ids)


State 24

    4 fx: FUNCTION id SEMICOLON BEGIN_PARAMS decs END_PARAMS BEGIN_LOCALS decs . END_LOCALS BEGIN_BODY statements END_BODY

    END_LOCALS  shift, and go to state 26


State 25

    8 dec: ids COLON ARRAY L_SQUARE_BRACKET . number R_SQUARE_BRACKET OF INTEGER

    NUMBER  shift, and go to state 27

    number  go to state 28


State 26

    4 fx: FUNCTION id SEMICOLON BEGIN_PARAMS decs END_PARAMS BEGIN_LOCALS decs END_LOCALS . BEGIN_BODY statements END_BODY

    BEGIN_BODY  shift, and go to state 29


State 27

   64 number: NUMBER .

    $default  reduce using rule 64 (number)


State 28

    8 dec: ids COLON ARRAY L_SQUARE_BRACKET number . R_SQUARE_BRACKET OF INTEGER

    R_SQUARE_BRACKET  shift, and go to state 30


State 29

    4 fx: FUNCTION id SEMICOLON BEGIN_PARAMS decs END_PARAMS BEGIN_LOCALS decs END_LOCALS BEGIN_BODY . statements END_BODY

    IDENT     shift, and go to state 5
    IF        shift, and go to state 31
    WHILE     shift, and go to state 32
    DO        shift, and go to state 33
    BREAK     shift, and go to state 34
    CONTINUE  shift, and go to state 35
    READ      shift, and go to state 36
    WRITE     shift, and go to state 37
    RETURN    shift, and go to state 38
    FOR       shift, and go to state 39

    id           go to state 40
    statements   go to state 41
    statement    go to state 42
    st_break     go to state 43
    st_return    go to state 44
    st_continue  go to state 45
    st_write     go to state 46
    st_read      go to state 47
    st_while     go to state 48
    st_if        go to state 49
    st_do        go to state 50
    st_for       go to state 51
    st_var       go to state 52
    x            go to state 53


State 30

    8 dec: ids COLON ARRAY L_SQUARE_BRACKET number R_SQUARE_BRACKET . OF INTEGER

    OF  shift, and go to state 54


State 31

   30 st_if: IF . bool_exp THEN statements ENDIF

    NUMBER   shift, and go to state 27
    IDENT    shift, and go to state 5
    TRUE     shift, and go to state 55
    FALSE    shift, and go to state 56
    NOT      shift, and go to state 57
    L_PAREN  shift, and go to state 58

    id                  go to state 59
    bool_exp            go to state 60
    relation_exps       go to state 61
    relation_exp        go to state 62
    exp_comp            go to state 63
    x                   go to state 64
    expression          go to state 65
    multiplicative_exp  go to state 66
    term                go to state 67
    number              go to state 68


State 32

   29 st_while: WHILE . bool_exp BEGIN_LOOP statements END_LOOP

    NUMBER   shift, and go to state 27
    IDENT    shift, and go to state 5
    TRUE     shift, and go to state 55
    FALSE    shift, and go to state 56
    NOT      shift, and go to state 57
    L_PAREN  shift, and go to state 58

    id                  go to state 59
    bool_exp            go to state 69
    relation_exps       go to state 61
    relation_exp        go to state 62
    exp_comp            go to state 63
    x                   go to state 64
    expression          go to state 65
    multiplicative_exp  go to state 66
    term                go to state 67
    number              go to state 68


State 33

   31 st_do: DO . BEGIN_LOOP statements END_LOOP

    BEGIN_LOOP  shift, and go to state 70


State 34

   24 st_break: BREAK .

    $default  reduce using rule 24 (st_break)


State 35

   26 st_continue: CONTINUE .

    $default  reduce using rule 26 (st_continue)


State 36

   28 st_read: READ . x

    IDENT  shift, and go to state 5

    id  go to state 40
    x   go to state 71


State 37

   27 st_write: WRITE . x

    IDENT  shift, and go to state 5

    id  go to state 40
    x   go to state 72


State 38

   25 st_return: RETURN . expression

    NUMBER   shift, and go to state 27
    IDENT    shift, and go to state 5
    L_PAREN  shift, and go to state 73

    id                  go to state 59
    x                   go to state 64
    expression          go to state 74
    multiplicative_exp  go to state 66
    term                go to state 67
    number              go to state 68


State 39

   32 st_for: FOR . x ASSIGN number SEMICOLON bool_exp SEMICOLON x ASSIGN expression BEGIN_LOOP statements END_LOOP

    IDENT  shift, and go to state 5

    id  go to state 40
    x   go to state 75


State 40

   49 x: id .
   50  | id . L_SQUARE_BRACKET expression R_SQUARE_BRACKET
   51  | id . L_SQUARE_BRACKET expression R_SQUARE_BRACKET L_SQUARE_BRACKET expression R_SQUARE_BRACKET

    L_SQUARE_BRACKET  shift, and go to state 76

    $default  reduce using rule 49 (x)


State 41

    4 fx: FUNCTION id SEMICOLON BEGIN_PARAMS decs END_PARAMS BEGIN_LOCALS decs END_LOCALS BEGIN_BODY statements . END_BODY

    END_BODY  shift, and go to state 77


State 42

   12 statements: statement . SEMICOLON statements
   13           | statement . SEMICOLON

    SEMICOLON  shift, and go to state 78


State 43

   16 statement: st_break .

    $default  reduce using rule 16 (statement)


State 44

   14 statement: st_return .

    $default  reduce using rule 14 (statement)


State 45

   15 statement: st_continue .

    $default  reduce using rule 15 (statement)


State 46

   17 statement: st_write .

    $default  reduce using rule 17 (statement)


State 47

   18 statement: st_read .

    $default  reduce using rule 18 (statement)


State 48

   19 statement: st_while .

    $default  reduce using rule 19 (statement)


State 49

   20 statement: st_if .

    $default  reduce using rule 20 (statement)


State 50

   22 statement: st_do .

    $default  reduce using rule 22 (statement)


State 51

   23 statement: st_for .

    $default  reduce using rule 23 (statement)


State 52

   21 statement: st_var .

    $default  reduce using rule 21 (statement)


State 53

   48 st_var: x . ASSIGN expression

    ASSIGN  shift, and go to state 79


State 54

    8 dec: ids COLON ARRAY L_SQUARE_BRACKET number R_SQUARE_BRACKET OF . INTEGER

    INTEGER  shift, and go to state 80


State 55

   39 relation_exp: TRUE .

    $default  reduce using rule 39 (relation_exp)


State 56

   40 relation_exp: FALSE .

    $default  reduce using rule 40 (relation_exp)


State 57

   37 relation_exp: NOT . exp_comp

    NUMBER   shift, and go to state 27
    IDENT    shift, and go to state 5
    L_PAREN  shift, and go to state 73

    id                  go to state 59
    exp_comp            go to state 81
    x                   go to state 64
    expression          go to state 65
    multiplicative_exp  go to state 66
    term                go to state 67
    number              go to state 68


State 58

   41 relation_exp: L_PAREN . bool_exp R_PAREN
   62 term: L_PAREN . expression R_PAREN

    NUMBER   shift, and go to state 27
    IDENT    shift, and go to state 5
    TRUE     shift, and go to state 55
    FALSE    shift, and go to state 56
    NOT      shift, and go to state 57
    L_PAREN  shift, and go to state 58

    id                  go to state 59
    bool_exp            go to state 82
    relation_exps       go to state 61
    relation_exp        go to state 62
    exp_comp            go to state 63
    x                   go to state 64
    expression          go to state 83
    multiplicative_exp  go to state 66
    term                go to state 67
    number              go to state 68


State 59

   49 x: id .
   50  | id . L_SQUARE_BRACKET expression R_SQUARE_BRACKET
   51  | id . L_SQUARE_BRACKET expression R_SQUARE_BRACKET L_SQUARE_BRACKET expression R_SQUARE_BRACKET
   63 term: id . L_PAREN expression exp_loop R_PAREN

    L_PAREN           shift, and go to state 84
    L_SQUARE_BRACKET  shift, and go to state 76

    $default  reduce using rule 49 (x)


State 60

   30 st_if: IF bool_exp . THEN statements ENDIF
   34 bool_exp: bool_exp . OR relation_exps

    THEN  shift, and go to state 85
    OR    shift, and go to state 86


State 61

   33 bool_exp: relation_exps .
   36 relation_exps: relation_exps . AND relation_exp

    AND  shift, and go to state 87

    $default  reduce using rule 33 (bool_exp)


State 62

   35 relation_exps: relation_exp .

    $default  reduce using rule 35 (relation_exps)


State 63

   38 relation_exp: exp_comp .

    $default  reduce using rule 38 (relation_exp)


State 64

   60 term: x .

    $default  reduce using rule 60 (term)


State 65

   42 exp_comp: expression . comp expression

    EQ   shift, and go to state 88
    NEQ  shift, and go to state 89
    GT   shift, and go to state 90
    LTE  shift, and go to state 91
    GTE  shift, and go to state 92

    comp  go to state 93


State 66

   52 expression: multiplicative_exp . add_sub_exp

    SUB  shift, and go to state 94
    ADD  shift, and go to state 95

    $default  reduce using rule 59 (add_sub_exp)

    add_sub_exp  go to state 96


State 67

   53 multiplicative_exp: term .
   54                   | term . MULT multiplicative_exp
   55                   | term . DIV multiplicative_exp
   56                   | term . MOD multiplicative_exp

    MULT  shift, and go to state 97
    DIV   shift, and go to state 98
    MOD   shift, and go to state 99

    $default  reduce using rule 53 (multiplicative_exp)


State 68

   61 term: number .

    $default  reduce using rule 61 (term)


State 69

   29 st_while: WHILE bool_exp . BEGIN_LOOP statements END_LOOP
   34 bool_exp: bool_exp . OR relation_exps

    BEGIN_LOOP  shift, and go to state 100
    OR          shift, and go to state 86


State 70

   31 st_do: DO BEGIN_LOOP . statements END_LOOP

    IDENT     shift, and go to state 5
    IF        shift, and go to state 31
    WHILE     shift, and go to state 32
    DO        shift, and go to state 33
    BREAK     shift, and go to state 34
    CONTINUE  shift, and go to state 35
    READ      shift, and go to state 36
    WRITE     shift, and go to state 37
    RETURN    shift, and go to state 38
    FOR       shift, and go to state 39

    id           go to state 40
    statements   go to state 101
    statement    go to state 42
    st_break     go to state 43
    st_return    go to state 44
    st_continue  go to state 45
    st_write     go to state 46
    st_read      go to state 47
    st_while     go to state 48
    st_if        go to state 49
    st_do        go to state 50
    st_for       go to state 51
    st_var       go to state 52
    x            go to state 53


State 71

   28 st_read: READ x .

    $default  reduce using rule 28 (st_read)


State 72

   27 st_write: WRITE x .

    $default  reduce using rule 27 (st_write)


State 73

   62 term: L_PAREN . expression R_PAREN

    NUMBER   shift, and go to state 27
    IDENT    shift, and go to state 5
    L_PAREN  shift, and go to state 73

    id                  go to state 59
    x                   go to state 64
    expression          go to state 102
    multiplicative_exp  go to state 66
    term                go to state 67
    number              go to state 68


State 74

   25 st_return: RETURN expression .

    $default  reduce using rule 25 (st_return)


State 75

   32 st_for: FOR x . ASSIGN number SEMICOLON bool_exp SEMICOLON x ASSIGN expression BEGIN_LOOP statements END_LOOP

    ASSIGN  shift, and go to state 103


State 76

   50 x: id L_SQUARE_BRACKET . expression R_SQUARE_BRACKET
   51  | id L_SQUARE_BRACKET . expression R_SQUARE_BRACKET L_SQUARE_BRACKET expression R_SQUARE_BRACKET

    NUMBER   shift, and go to state 27
    IDENT    shift, and go to state 5
    L_PAREN  shift, and go to state 73

    id                  go to state 59
    x                   go to state 64
    expression          go to state 104
    multiplicative_exp  go to state 66
    term                go to state 67
    number              go to state 68


State 77

    4 fx: FUNCTION id SEMICOLON BEGIN_PARAMS decs END_PARAMS BEGIN_LOCALS decs END_LOCALS BEGIN_BODY statements END_BODY .

    $default  reduce using rule 4 (fx)


State 78

   12 statements: statement SEMICOLON . statements
   13           | statement SEMICOLON .

    IDENT     shift, and go to state 5
    IF        shift, and go to state 31
    WHILE     shift, and go to state 32
    DO        shift, and go to state 33
    BREAK     shift, and go to state 34
    CONTINUE  shift, and go to state 35
    READ      shift, and go to state 36
    WRITE     shift, and go to state 37
    RETURN    shift, and go to state 38
    FOR       shift, and go to state 39

    $default  reduce using rule 13 (statements)

    id           go to state 40
    statements   go to state 105
    statement    go to state 42
    st_break     go to state 43
    st_return    go to state 44
    st_continue  go to state 45
    st_write     go to state 46
    st_read      go to state 47
    st_while     go to state 48
    st_if        go to state 49
    st_do        go to state 50
    st_for       go to state 51
    st_var       go to state 52
    x            go to state 53


State 79

   48 st_var: x ASSIGN . expression

    NUMBER   shift, and go to state 27
    IDENT    shift, and go to state 5
    L_PAREN  shift, and go to state 73

    id                  go to state 59
    x                   go to state 64
    expression          go to state 106
    multiplicative_exp  go to state 66
    term                go to state 67
    number              go to state 68


State 80

    8 dec: ids COLON ARRAY L_SQUARE_BRACKET number R_SQUARE_BRACKET OF INTEGER .

    $default  reduce using rule 8 (dec)


State 81

   37 relation_exp: NOT exp_comp .

    $default  reduce using rule 37 (relation_exp)


State 82

   34 bool_exp: bool_exp . OR relation_exps
   41 relation_exp: L_PAREN bool_exp . R_PAREN

    OR       shift, and go to state 86
    R_PAREN  shift, and go to state 107


State 83

   42 exp_comp: expression . comp expression
   62 term: L_PAREN expression . R_PAREN

    EQ       shift, and go to state 88
    NEQ      shift, and go to state 89
    GT       shift, and go to state 90
    LTE      shift, and go to state 91
    GTE      shift, and go to state 92
    R_PAREN  shift, and go to state 108

    comp  go to state 93


State 84

   63 term: id L_PAREN . expression exp_loop R_PAREN

    NUMBER   shift, and go to state 27
    IDENT    shift, and go to state 5
    L_PAREN  shift, and go to state 73

    id                  go to state 59
    x                   go to state 64
    expression          go to state 109
    multiplicative_exp  go to state 66
    term                go to state 67
    number              go to state 68


State 85

   30 st_if: IF bool_exp THEN . statements ENDIF

    IDENT     shift, and go to state 5
    IF        shift, and go to state 31
    WHILE     shift, and go to state 32
    DO        shift, and go to state 33
    BREAK     shift, and go to state 34
    CONTINUE  shift, and go to state 35
    READ      shift, and go to state 36
    WRITE     shift, and go to state 37
    RETURN    shift, and go to state 38
    FOR       shift, and go to state 39

    id           go to state 40
    statements   go to state 110
    statement    go to state 42
    st_break     go to state 43
    st_return    go to state 44
    st_continue  go to state 45
    st_write     go to state 46
    st_read      go to state 47
    st_while     go to state 48
    st_if        go to state 49
    st_do        go to state 50
    st_for       go to state 51
    st_var       go to state 52
    x            go to state 53


State 86

   34 bool_exp: bool_exp OR . relation_exps

    NUMBER   shift, and go to state 27
    IDENT    shift, and go to state 5
    TRUE     shift, and go to state 55
    FALSE    shift, and go to state 56
    NOT      shift, and go to state 57
    L_PAREN  shift, and go to state 58

    id                  go to state 59
    relation_exps       go to state 111
    relation_exp        go to state 62
    exp_comp            go to state 63
    x                   go to state 64
    expression          go to state 65
    multiplicative_exp  go to state 66
    term                go to state 67
    number              go to state 68


State 87

   36 relation_exps: relation_exps AND . relation_exp

    NUMBER   shift, and go to state 27
    IDENT    shift, and go to state 5
    TRUE     shift, and go to state 55
    FALSE    shift, and go to state 56
    NOT      shift, and go to state 57
    L_PAREN  shift, and go to state 58

    id                  go to state 59
    relation_exp        go to state 112
    exp_comp            go to state 63
    x                   go to state 64
    expression          go to state 65
    multiplicative_exp  go to state 66
    term                go to state 67
    number              go to state 68


State 88

   43 comp: EQ .

    $default  reduce using rule 43 (comp)


State 89

   44 comp: NEQ .

    $default  reduce using rule 44 (comp)


State 90

   45 comp: GT .

    $default  reduce using rule 45 (comp)


State 91

   46 comp: LTE .

    $default  reduce using rule 46 (comp)


State 92

   47 comp: GTE .

    $default  reduce using rule 47 (comp)


State 93

   42 exp_comp: expression comp . expression

    NUMBER   shift, and go to state 27
    IDENT    shift, and go to state 5
    L_PAREN  shift, and go to state 73

    id                  go to state 59
    x                   go to state 64
    expression          go to state 113
    multiplicative_exp  go to state 66
    term                go to state 67
    number              go to state 68


State 94

   58 add_sub_exp: SUB . expression

    NUMBER   shift, and go to state 27
    IDENT    shift, and go to state 5
    L_PAREN  shift, and go to state 73

    id                  go to state 59
    x                   go to state 64
    expression          go to state 114
    multiplicative_exp  go to state 66
    term                go to state 67
    number              go to state 68


State 95

   57 add_sub_exp: ADD . expression

    NUMBER   shift, and go to state 27
    IDENT    shift, and go to state 5
    L_PAREN  shift, and go to state 73

    id                  go to state 59
    x                   go to state 64
    expression          go to state 115
    multiplicative_exp  go to state 66
    term                go to state 67
    number              go to state 68


State 96

   52 expression: multiplicative_exp add_sub_exp .

    $default  reduce using rule 52 (expression)


State 97

   54 multiplicative_exp: term MULT . multiplicative_exp

    NUMBER   shift, and go to state 27
    IDENT    shift, and go to state 5
    L_PAREN  shift, and go to state 73

    id                  go to state 59
    x                   go to state 64
    multiplicative_exp  go to state 116
    term                go to state 67
    number              go to state 68


State 98

   55 multiplicative_exp: term DIV . multiplicative_exp

    NUMBER   shift, and go to state 27
    IDENT    shift, and go to state 5
    L_PAREN  shift, and go to state 73

    id                  go to state 59
    x                   go to state 64
    multiplicative_exp  go to state 117
    term                go to state 67
    number              go to state 68


State 99

   56 multiplicative_exp: term MOD . multiplicative_exp

    NUMBER   shift, and go to state 27
    IDENT    shift, and go to state 5
    L_PAREN  shift, and go to state 73

    id                  go to state 59
    x                   go to state 64
    multiplicative_exp  go to state 118
    term                go to state 67
    number              go to state 68


State 100

   29 st_while: WHILE bool_exp BEGIN_LOOP . statements END_LOOP

    IDENT     shift, and go to state 5
    IF        shift, and go to state 31
    WHILE     shift, and go to state 32
    DO        shift, and go to state 33
    BREAK     shift, and go to state 34
    CONTINUE  shift, and go to state 35
    READ      shift, and go to state 36
    WRITE     shift, and go to state 37
    RETURN    shift, and go to state 38
    FOR       shift, and go to state 39

    id           go to state 40
    statements   go to state 119
    statement    go to state 42
    st_break     go to state 43
    st_return    go to state 44
    st_continue  go to state 45
    st_write     go to state 46
    st_read      go to state 47
    st_while     go to state 48
    st_if        go to state 49
    st_do        go to state 50
    st_for       go to state 51
    st_var       go to state 52
    x            go to state 53


State 101

   31 st_do: DO BEGIN_LOOP statements . END_LOOP

    END_LOOP  shift, and go to state 120


State 102

   62 term: L_PAREN expression . R_PAREN

    R_PAREN  shift, and go to state 108


State 103

   32 st_for: FOR x ASSIGN . number SEMICOLON bool_exp SEMICOLON x ASSIGN expression BEGIN_LOOP statements END_LOOP

    NUMBER  shift, and go to state 27

    number  go to state 121


State 104

   50 x: id L_SQUARE_BRACKET expression . R_SQUARE_BRACKET
   51  | id L_SQUARE_BRACKET expression . R_SQUARE_BRACKET L_SQUARE_BRACKET expression R_SQUARE_BRACKET

    R_SQUARE_BRACKET  shift, and go to state 122


State 105

   12 statements: statement SEMICOLON statements .

    $default  reduce using rule 12 (statements)


State 106

   48 st_var: x ASSIGN expression .

    $default  reduce using rule 48 (st_var)


State 107

   41 relation_exp: L_PAREN bool_exp R_PAREN .

    $default  reduce using rule 41 (relation_exp)


State 108

   62 term: L_PAREN expression R_PAREN .

    $default  reduce using rule 62 (term)


State 109

   63 term: id L_PAREN expression . exp_loop R_PAREN

    COMMA  shift, and go to state 123

    $default  reduce using rule 66 (exp_loop)

    exp_loop  go to state 124


State 110

   30 st_if: IF bool_exp THEN statements . ENDIF

    ENDIF  shift, and go to state 125


State 111

   34 bool_exp: bool_exp OR relation_exps .
   36 relation_exps: relation_exps . AND relation_exp

    AND  shift, and go to state 87

    $default  reduce using rule 34 (bool_exp)


State 112

   36 relation_exps: relation_exps AND relation_exp .

    $default  reduce using rule 36 (relation_exps)


State 113

   42 exp_comp: expression comp expression .

    $default  reduce using rule 42 (exp_comp)


State 114

   58 add_sub_exp: SUB expression .

    $default  reduce using rule 58 (add_sub_exp)


State 115

   57 add_sub_exp: ADD expression .

    $default  reduce using rule 57 (add_sub_exp)


State 116

   54 multiplicative_exp: term MULT multiplicative_exp .

    $default  reduce using rule 54 (multiplicative_exp)


State 117

   55 multiplicative_exp: term DIV multiplicative_exp .

    $default  reduce using rule 55 (multiplicative_exp)


State 118

   56 multiplicative_exp: term MOD multiplicative_exp .

    $default  reduce using rule 56 (multiplicative_exp)


State 119

   29 st_while: WHILE bool_exp BEGIN_LOOP statements . END_LOOP

    END_LOOP  shift, and go to state 126


State 120

   31 st_do: DO BEGIN_LOOP statements END_LOOP .

    $default  reduce using rule 31 (st_do)


State 121

   32 st_for: FOR x ASSIGN number . SEMICOLON bool_exp SEMICOLON x ASSIGN expression BEGIN_LOOP statements END_LOOP

    SEMICOLON  shift, and go to state 127


State 122

   50 x: id L_SQUARE_BRACKET expression R_SQUARE_BRACKET .
   51  | id L_SQUARE_BRACKET expression R_SQUARE_BRACKET . L_SQUARE_BRACKET expression R_SQUARE_BRACKET

    L_SQUARE_BRACKET  shift, and go to state 128

    $default  reduce using rule 50 (x)


State 123

   65 exp_loop: COMMA . expression exp_loop

    NUMBER   shift, and go to state 27
    IDENT    shift, and go to state 5
    L_PAREN  shift, and go to state 73

    id                  go to state 59
    x                   go to state 64
    expression          go to state 129
    multiplicative_exp  go to state 66
    term                go to state 67
    number              go to state 68


State 124

   63 term: id L_PAREN expression exp_loop . R_PAREN

    R_PAREN  shift, and go to state 130


State 125

   30 st_if: IF bool_exp THEN statements ENDIF .

    $default  reduce using rule 30 (st_if)


State 126

   29 st_while: WHILE bool_exp BEGIN_LOOP statements END_LOOP .

    $default  reduce using rule 29 (st_while)


State 127

   32 st_for: FOR x ASSIGN number SEMICOLON . bool_exp SEMICOLON x ASSIGN expression BEGIN_LOOP statements END_LOOP

    NUMBER   shift, and go to state 27
    IDENT    shift, and go to state 5
    TRUE     shift, and go to state 55
    FALSE    shift, and go to state 56
    NOT      shift, and go to state 57
    L_PAREN  shift, and go to state 58

    id                  go to state 59
    bool_exp            go to state 131
    relation_exps       go to state 61
    relation_exp        go to state 62
    exp_comp            go to state 63
    x                   go to state 64
    expression          go to state 65
    multiplicative_exp  go to state 66
    term                go to state 67
    number              go to state 68


State 128

   51 x: id L_SQUARE_BRACKET expression R_SQUARE_BRACKET L_SQUARE_BRACKET . expression R_SQUARE_BRACKET

    NUMBER   shift, and go to state 27
    IDENT    shift, and go to state 5
    L_PAREN  shift, and go to state 73

    id                  go to state 59
    x                   go to state 64
    expression          go to state 132
    multiplicative_exp  go to state 66
    term                go to state 67
    number              go to state 68


State 129

   65 exp_loop: COMMA expression . exp_loop

    COMMA  shift, and go to state 123

    $default  reduce using rule 66 (exp_loop)

    exp_loop  go to state 133


State 130

   63 term: id L_PAREN expression exp_loop R_PAREN .

    $default  reduce using rule 63 (term)


State 131

   32 st_for: FOR x ASSIGN number SEMICOLON bool_exp . SEMICOLON x ASSIGN expression BEGIN_LOOP statements END_LOOP
   34 bool_exp: bool_exp . OR relation_exps

    OR         shift, and go to state 86
    SEMICOLON  shift, and go to state 134


State 132

   51 x: id L_SQUARE_BRACKET expression R_SQUARE_BRACKET L_SQUARE_BRACKET expression . R_SQUARE_BRACKET

    R_SQUARE_BRACKET  shift, and go to state 135


State 133

   65 exp_loop: COMMA expression exp_loop .

    $default  reduce using rule 65 (exp_loop)


State 134

   32 st_for: FOR x ASSIGN number SEMICOLON bool_exp SEMICOLON . x ASSIGN expression BEGIN_LOOP statements END_LOOP

    IDENT  shift, and go to state 5

    id  go to state 40
    x   go to state 136


State 135

   51 x: id L_SQUARE_BRACKET expression R_SQUARE_BRACKET L_SQUARE_BRACKET expression R_SQUARE_BRACKET .

    $default  reduce using rule 51 (x)


State 136

   32 st_for: FOR x ASSIGN number SEMICOLON bool_exp SEMICOLON x . ASSIGN expression BEGIN_LOOP statements END_LOOP

    ASSIGN  shift, and go to state 137


State 137

   32 st_for: FOR x ASSIGN number SEMICOLON bool_exp SEMICOLON x ASSIGN . expression BEGIN_LOOP statements END_LOOP

    NUMBER   shift, and go to state 27
    IDENT    shift, and go to state 5
    L_PAREN  shift, and go to state 73

    id                  go to state 59
    x                   go to state 64
    expression          go to state 138
    multiplicative_exp  go to state 66
    term                go to state 67
    number              go to state 68


State 138

   32 st_for: FOR x ASSIGN number SEMICOLON bool_exp SEMICOLON x ASSIGN expression . BEGIN_LOOP statements END_LOOP

    BEGIN_LOOP  shift, and go to state 139


State 139

   32 st_for: FOR x ASSIGN number SEMICOLON bool_exp SEMICOLON x ASSIGN expression BEGIN_LOOP . statements END_LOOP

    IDENT     shift, and go to state 5
    IF        shift, and go to state 31
    WHILE     shift, and go to state 32
    DO        shift, and go to state 33
    BREAK     shift, and go to state 34
    CONTINUE  shift, and go to state 35
    READ      shift, and go to state 36
    WRITE     shift, and go to state 37
    RETURN    shift, and go to state 38
    FOR       shift, and go to state 39

    id           go to state 40
    statements   go to state 140
    statement    go to state 42
    st_break     go to state 43
    st_return    go to state 44
    st_continue  go to state 45
    st_write     go to state 46
    st_read      go to state 47
    st_while     go to state 48
    st_if        go to state 49
    st_do        go to state 50
    st_for       go to state 51
    st_var       go to state 52
    x            go to state 53


State 140

   32 st_for: FOR x ASSIGN number SEMICOLON bool_exp SEMICOLON x ASSIGN expression BEGIN_LOOP statements . END_LOOP

    END_LOOP  shift, and go to state 141


State 141

   32 st_for: FOR x ASSIGN number SEMICOLON bool_exp SEMICOLON x ASSIGN expression BEGIN_LOOP statements END_LOOP .

    $default  reduce using rule 32 (st_for)
